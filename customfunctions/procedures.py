"""Helps Manage Snowflake Connection"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_procedures.ipynb.

# %% auto 0
__all__ = ['hello_procedure', 'test_procedure', 'perform_aggregation']

# %% ../nbs/03_procedures.ipynb 3
from pathlib import Path
from snowflake.snowpark import Session
from snowflake.snowpark.functions import col, sum, avg, count, to_char, current_timestamp
from .common import load_config, get_config_path, is_snowflake_environment, find_config_file


from typing import Optional, Dict
import sys
import json
import os
import yaml
import logging
import zipfile

# %% ../nbs/03_procedures.ipynb 4
def hello_procedure(session: Optional[Session] = None, name: str = "World") -> str:
    """
    Enhanced hello procedure that works both locally and in Snowflake.
    
    Args:
        session: Snowflake session (optional, only needed in Snowflake environment)
        name: Name to greet
    
    Returns:
        Greeting string
    """
    try:
        # Get config path based on environment
        config_path = get_config_path()
        
        # Load configuration
        config = load_config(config_path)
        
        # Get additional word from config, with fallback
        added_word = config.get('added_word', '')
        
        # Build and return greeting
        greeting = f"Hello, {name}!"
        if added_word:
            greeting += f" {added_word}"
            
        return greeting
        
    except Exception as e:
        logging.error(f"Error in hello_procedure: {e}")
        # Return a basic greeting in case of any errors
        return f"Hello, {name}!"


# %% ../nbs/03_procedures.ipynb 6
def test_procedure(session: Session) -> str:
    return "Test procedure"

# %% ../nbs/03_procedures.ipynb 7
def perform_aggregation(session: Session, aggregation_request: str) -> str:
    """
    Performs data aggregation based on the provided aggregation request.

    This function takes a Snowflake session and an aggregation request in JSON format,
    applies the specified filters, groups the data, calculates the requested metrics,
    and saves the results to a target table in Snowflake.

    Parameters
    session : snowflake.snowpark.Session
        An active Snowflake session object.
    aggregation_request : str
        A JSON string containing the aggregation specifications. It should include:
        - source_table: Name of the source table in Snowflake.
        - target_table: Name of the table where results will be saved.
        - group_by: List of columns to group by.
        - metrics: List of metrics to calculate, each with a name, function, and column.
        - filters: List of filters to apply to the data.

    The aggregation_request should have the following structure:
        - TODO: Think about fine grain control, but for now you can have 
                <database>.<schema>.<table> and if the caller has access
                then it will work correctly.
    {
        "source_table": str,
        "target_table": str,
        "group_by": List[str],
        "metrics": List[Dict[str, str]],
        "filters": List[Dict[str, Union[str, List[str]]]]
    }

    Returns:
    --------
    None
        The function doesn't return a value, but it prints a confirmation message
        and saves the results to the specified target table in Snowflake.
    """

    request = json.loads(aggregation_request)
    
    df = session.table(request['source_table'])
    for filter in request['filters']:
        if filter['operator'] == 'between':
            df = df.filter((col(filter['column']) >= filter['value'][0]) & 
                           (col(filter['column']) <= filter['value'][1]))
        elif filter['operator'] == 'in':
            df = df.filter(col(filter['column']).isin(filter['value']))

    df = df.group_by(request['group_by'])

    aggs = []
    for metric in request['metrics']:
        if metric['function'] == 'sum':
            aggs.append(sum(col(metric['column'])).alias(metric['name']))
        elif metric['function'] == 'avg':
            aggs.append(avg(col(metric['column'])).alias(metric['name']))
        elif metric['function'] == 'count':
            aggs.append(count(col(metric['column'])).alias(metric['name']))
    df = df.agg(*aggs).with_column('created', to_char(current_timestamp(), 'YYYY-MM-DD HH24:MI:SS'))
    
    df.write.mode("overwrite").save_as_table(request['target_table'])
    
    return f"Aggregation completed. Results saved to {request['target_table']}"
